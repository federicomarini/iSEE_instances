# Code for generating an instance of iSEE for the data from Dahlin et al, 2018

Paper: http://www.bloodjournal.org/content/131/21/e1.long?sso-checked=true

Data: The data reported in this article have been deposited in the Gene Expression Omnibus database (accession numbers GSE106973 and GSE107727).


## GSE106973

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE106973
-> https://www.ncbi.nlm.nih.gov/sra?term=SRP125087

Single cell RNA-sequencing of 94 basophil/mast cell progenitors (BMCPs) and 47 granulocyte/monocyte progenitors (GMPs) isolated from bone marrow of three female C57BL/6 mice.

```{r}
setwd("iSEE_dahlin_blood")
```


```{r eval=FALSE}
download.file("https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE106973&format=file&file=GSE106973%5FHTSeq%5Fcounts%2Etxt%2Egz",
              destfile = "scrnaseq_counts_GSE106973.txt.gz")
```

```{r}
sccm <- read.table("scrnaseq_counts_GSE106973.txt.gz",sep = "\t",header = TRUE)
rownames(sccm) <- sccm$ID
dim(sccm)

head(sccm)
sccm <- sccm[,-1]
head(sccm)

# remove last lines
tail(sccm)
sccm <- sccm[-grep("__",rownames(sccm)),]
tail(sccm)
# there are spike ins!
```


The default set:

```{r}
library(scRNAseq)
data(allen)
class(allen)
library(scater)
sce <- as(allen, "SingleCellExperiment")
counts(sce) <- assay(sce, "tophat_counts")
sce <- normalize(sce)
sce <- runPCA(sce)
sce <- runTSNE(sce)
rowData(sce)$ave_count <- rowMeans(counts(sce))
rowData(sce)$n_cells <- rowSums(counts(sce)>0)
sce
# launch the app itself ----
library(iSEE)
iSEE(sce)
```

This one set:

```{r}
se <- SummarizedExperiment(assays = SimpleList(counts = as.matrix(sccm)))
colData(se) <- DataFrame(
  id = colnames(sccm)
)
dim(se)

colnames(se) <- colnames(sccm)
se$celltype <- unlist(lapply(
  strsplit(se$id,split = "_"),
  function(arg) arg[[1]]))

sce <- as(se, "SingleCellExperiment")
sce <- normalize(sce)
sce <- runPCA(sce)
sce <- runTSNE(sce)
rowData(sce)$ave_count <- rowMeans(counts(sce))
rowData(sce)$n_cells <- rowSums(counts(sce)>0)
sce
# launch the app itself ----
library(iSEE)
iSEE(sce)
```



## GSE107727

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107727
-> https://www.ncbi.nlm.nih.gov/sra?term=SRP126188

To determine the transcriptional landscape of mouse HSPCs in normal and perturbed haematopoiesis.

Downloading the raw data and uncompressing the folder...

```{r}
download.file("https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE107727&format=file",
              destfile = "GSE107727_RAW.tar")

# manually untarring -.-
```

### Reading in the 6 files - SIGAB1-SIGAH1

```{r}
library(SingleCellExperiment)

# cm <- read.table("MINITEST.txt",sep = "\t")

cm_SIGAB1 <- read.table("GSE107727_RAW/GSM2877127_SIGAB1_counts.txt.gz", sep = "\t")
cm_SIGAC1 <- read.table("GSE107727_RAW/GSM2877128_SIGAC1_counts.txt.gz", sep = "\t")
cm_SIGAD1 <- read.table("GSE107727_RAW/GSM2877129_SIGAD1_counts.txt.gz", sep = "\t")
cm_SIGAF1 <- read.table("GSE107727_RAW/GSM2877130_SIGAF1_counts.txt.gz", sep = "\t")
cm_SIGAG1 <- read.table("GSE107727_RAW/GSM2877131_SIGAG1_counts.txt.gz", sep = "\t")
cm_SIGAH1 <- read.table("GSE107727_RAW/GSM2877132_SIGAH1_counts.txt.gz", sep = "\t")


# checking everything is correctly in there?
gplots::venn(list(
  rownames(cm_SIGAB1),
  rownames(cm_SIGAC1),
  rownames(cm_SIGAD1)
)
)
gplots::venn(list(
  rownames(cm_SIGAF1),
  rownames(cm_SIGAG1),
  rownames(cm_SIGAH1)
)
)

gplots::venn(list(
  colnames(cm_SIGAB1),
  colnames(cm_SIGAC1),
  colnames(cm_SIGAD1)
)

# make the colnames unique, just to be safer:
colnames(cm_SIGAB1) <- paste0("SIGAB1-",colnames(cm_SIGAB1))
colnames(cm_SIGAC1) <- paste0("SIGAC1-",colnames(cm_SIGAC1))
colnames(cm_SIGAD1) <- paste0("SIGAD1-",colnames(cm_SIGAD1))
colnames(cm_SIGAF1) <- paste0("SIGAF1-",colnames(cm_SIGAF1))
colnames(cm_SIGAG1) <- paste0("SIGAG1-",colnames(cm_SIGAG1))
colnames(cm_SIGAH1) <- paste0("SIGAH1-",colnames(cm_SIGAH1))

# fulllist <- list(cm_SIGAB1[1:3,1:10],cm_SIGAC1[1:3,1:10],cm_SIGAD1[1:3,1:10],cm_SIGAF1[1:3,1:10],cm_SIGAG1[1:3,1:10],cm_SIGAH1[1:3,1:10])

fullmat <- do.call(cbind,
                   list(cm_SIGAB1,cm_SIGAC1,cm_SIGAD1,
                        cm_SIGAF1,cm_SIGAG1,cm_SIGAH1))
pryr::object_size(fullmat)
fullmat <- as.matrix(fullmat)
pryr::object_size(fullmat)
```

### To keep the memory footprint small...

```{r}
library(SingleCellExperiment)

fullmat <- as(fullmat, "dgCMatrix")
pryr::object_size(fullmat)

head(fullmat)
sce <- SingleCellExperiment(assays = list(counts = fullmat))

pryr::object_size(sce)

sce_blood <- sce
saveRDS(sce_blood,"sce_blood.RDS")
```

### Proceeding with the further processing...

Keeping in mind that some operations are quite memory-intensive...


```{r}
sce <- readRDS("sce_blood.RDS")
library("DropletUtils")
set.seed(100)
e.out <- emptyDrops(counts(sce))
e.keep <- e.out$FDR <= 0.01
summary(e.keep)

sce$Detection <- e.keep
sce$PValue <- e.out$PValue
# sce <- sce[,keep]
```

### Adding gene-level annotation

```{r}
library(AnnotationHub)
## Load the annotation resource.
ah <- AnnotationHub()

## Query for all available EnsDb databases
query(ah, c("92", "EnsDb","Homo"))
query(ah, c("92", "EnsDb","Musculus"))

edb_v92_human <- ah[["AH60977"]]
edb_v92_mouse <- ah[["AH60992"]]

symb <- mapIds(edb_v92_mouse, keys=rownames(sce), keytype="GENEID", column="SYMBOL")
rowData(sce)$ENSEMBL <- rownames(sce)
rowData(sce)$SYMBOL <- symb
head(rowData(sce))

library(scater)
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ENSEMBL, rowData(sce)$SYMBOL)
head(rownames(sce))

# We also determine the chromosomal location for each gene.

location <- mapIds(edb_v92_mouse, keys=rowData(sce)$ENSEMBL,
                   column="SEQNAME", keytype="GENEID")
rowData(sce)$CHR <- location
## e.g. ...
summary(location=="MT")
```

### Quality control on the cells

```{r}

# Cell detection can be considered an implicit quality control step, so technically, no extra steps are needed.
# Nonetheless, we examine some commonly used metrics.

sce <- calculateQCMetrics(sce, feature_controls=list(Mito=which(location=="MT")))
# par(mfrow=c(1,3))
hist(log10(sce$total_counts), breaks=20, col="grey80")
hist(log10(sce$total_features_by_counts), breaks=20, col="grey80")
hist(sce$pct_counts_Mito, breaks=20, col="grey80")

# Interestingly, a large number of the features with low total counts also have high mitochondrial proportions.

plot(sce$total_features_by_counts, sce$pct_counts_Mito)
plot(sce$total_counts, sce$pct_counts_Mito)

# This may indicate that the cells uniquely detected by EmptyDrops are, in fact, damaged.
# We'll have a look at this in more detail during the clustering step.

# Examining gene expression

# We have a look at the average expression of each gene.

ave <- calcAverage(sce)
rowData(sce)$AveCount <- ave
hist(log10(ave), col="grey80")

# We also examine the top-most expressed genes.
# This contains ribosomal protein genes and other usual suspects.

plotHighestExprs(sce,10)
```

### Normalizing for cell-specific biases

```{r}
# We perform some pre-clustering to break up obvious clusters.

library(scran)
clusters <- quickCluster(sce, method="igraph", subset.row=ave>=0.1,
                         irlba.args=list(maxit=1000)) # for convergence.
table(clusters)

# We then use the deconvolution method to compute size factors for each cell.

sce <- computeSumFactors(sce, min.mean=0.1, cluster=clusters)
summary(sizeFactors(sce))

# We can plot these against the library sizes to see how much of a difference it makes.

plot(sce$total_counts, sizeFactors(sce), log="xy")

# Note that some size factors are very small and negative.
# This represents cells that have so few expressed features that it is not possible to obtain a sensible size factor.

neg.sf <- sizeFactors(sce)<0
summary(neg.sf)

# Instead, we replace the size factor with the (scaled) library size.

library(Matrix)
lib.sizes <- colSums(counts(sce))
scaled.lib.sizes <- lib.sizes/mean(lib.sizes)
sizeFactors(sce)[neg.sf] <- scaled.lib.sizes[neg.sf]

# Finally, we compute normalized log-expresion values.

sce <- normalize(sce)

saveRDS(sce,"sce_blood_normalized.RDS")
```

### Modelling the mean-variance trend

```{r}
# We assume that the technical noise is Poisson and create a fitted trend on that basis.

new.trend <- makeTechTrend(x=sce)

# We actually estimate the variances and plot the trend against the original variances as well.

fit <- trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))
plot(fit$mean, fit$var, pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
curve(new.trend(x), col="red", add=TRUE)

# We decompose the variance and have a look at the genes with the highest residual.

dec <- decomposeVar(fit=fit)
top.dec <- dec[order(dec$bio, decreasing=TRUE),]
head(top.dec)

# We can plot the genes with the largest biological components, to verify that they are indeed highly variable.

plotExpression(sce, features = rownames(top.dec)[1:10])
```


